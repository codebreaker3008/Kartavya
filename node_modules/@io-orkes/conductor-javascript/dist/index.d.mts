import { O as OrkesApiConfig, C as ConductorHttpRequest, a as ConductorClient, b as ConductorClientAPIConfig, F as FetchFn, c as OpenAPIConfig, A as ApiRequestOptions, d as CancelablePromise } from './types-f83aa26f.js';
export { p as Action, m as ApiError, k as ApiResult, a6 as AssignmentPolicy, a8 as BackToAssigment, B as BaseHttpRequest, o as CancelError, a9 as ClearAssigment, au as CommonTaskDef, aR as ConductorError, ap as ConductorLogLevel, ao as ConductorLogger, h as ConductorWorker, ar as DefaultLogger, aq as DefaultLoggerConfig, ax as DoWhileTaskDef, aa as Escalate, E as EventHandler, _ as EventResourceService, ay as EventTaskDef, q as ExternalStorageLocation, ab as FFAAssignment, a7 as Fixed, aB as ForkJoinDynamicDef, az as ForkJoinTaskDef, G as GenerateTokenRequest, ac as HTScrollableSearchResultHumanTaskEntry, $ as HealthCheckResourceService, aC as HttpInputParameters, aD as HttpTaskDef, aT as HumanExecutor, ad as HumanTaskActionLogEntry, ae as HumanTaskEntry, af as HumanTaskLoad, ag as HumanTaskStateLogEntry, ah as HumanTaskTemplate, ai as HumanTaskTemplateEntry, aF as InlineTaskDef, aE as InlineTaskInputParameters, aA as JoinTaskDef, aG as JsonJQTransformTaskDef, aH as KafkaPublishInputParameters, aI as KafkaPublishTaskDef, aj as LeastBusyGroupMemberAssignment, a0 as MetadataResourceService, ak as Never, l as OnCancel, P as PollData, at as RequestType, r as RerunWorkflowRequest, s as Response, R as RunnerArgs, S as SaveScheduleRequest, a1 as SchedulerResourceService, t as ScrollableSearchResultWorkflowSummary, al as SearchResultHumanTaskEntry, u as SearchResultTask, v as SearchResultTaskSummary, w as SearchResultWorkflow, x as SearchResultWorkflowScheduleExecutionModel, y as SearchResultWorkflowSummary, aJ as SetVariableTaskDef, aK as SimpleTaskDef, z as SkipTaskRequest, D as StartWorkflow, H as StartWorkflowRequest, I as SubWorkflowParams, aL as SubWorkflowTaskDef, aM as SwitchTaskDef, J as Task, K as TaskDef, aw as TaskDefTypes, L as TaskDetails, i as TaskErrorHandler, M as TaskExecLog, g as TaskManager, f as TaskManagerConfig, e as TaskManagerOptions, a2 as TaskResourceService, N as TaskResult, aS as TaskResultStatus, T as TaskRunner, j as TaskRunnerOptions, Q as TaskSummary, av as TaskType, am as Terminate, aN as TerminateTaskDef, an as TimeoutPolicy, a3 as TokenResourceService, aO as WaitTaskDef, W as Workflow, a4 as WorkflowBulkResourceService, aP as WorkflowDef, aQ as WorkflowExecutor, a5 as WorkflowResourceService, U as WorkflowSchedule, V as WorkflowScheduleExecutionModel, X as WorkflowStatus, Y as WorkflowSummary, Z as WorkflowTask, aZ as conductorEventTask, aU as doWhileTask, aW as dynamicForkTask, aX as eventTask, a_ as forkTask, a$ as forkTaskJoin, br as generate, be as generateDoWhileTask, bf as generateEventTask, bg as generateForkJoinTask, bi as generateHTTPTask, bj as generateInlineTask, bk as generateJQTransformTask, bh as generateJoinTask, bl as generateKafkaPublishTask, bn as generateSetVariableTask, bd as generateSimpleTask, bm as generateSubWorkflowTask, bq as generateSwitchTask, bo as generateTerminateTask, bp as generateWaitTask, b0 as httpTask, b1 as inlineTask, b2 as joinTask, b3 as jsonJqTask, b4 as kafkaPublishTask, aV as newLoopTask, n as noopErrorHandler, as as noopLogger, b5 as setVariableTask, b6 as simpleTask, aY as sqsEventTask, b7 as subWorkflowTask, b8 as switchTask, bs as taskGenMapper, b9 as terminateTask, ba as waitTaskDuration, bb as waitTaskUntil, bc as workflow } from './types-f83aa26f.js';

/**
 * Takes a config with keyId and keySecret returns a promise with an instance of ConductorClient
 *
 * @param config ConductorClientConfig with keyId and keySecret
 * @param requestHandler (optional) ConductorHttpRequest handler
 * @returns
 */
declare const orkesConductorClient: (config?: Partial<OrkesApiConfig> | undefined, requestHandler?: ConductorHttpRequest) => Promise<ConductorClient>;

declare class AuthConductorClient extends ConductorClient {
    intervalId?: NodeJS.Timeout;
    constructor(config?: Partial<ConductorClientAPIConfig>, requestHandler?: ConductorHttpRequest);
    /**
     * Stops the interval that refreshes the token
     */
    stop(): void;
}
declare const baseOrkesConductorClient: <T = RequestInit, R extends {
    json: () => Promise<any>;
} = Response>(fetchFn: FetchFn<T, R>, baseRequestHandler?: ConductorHttpRequest) => (config?: Partial<OrkesApiConfig> | undefined, requestHandler?: ConductorHttpRequest) => Promise<ConductorClient>;

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
declare const request: <T>(config: OpenAPIConfig, options: ApiRequestOptions, fetchFn?: FetchFn) => CancelablePromise<T>;

declare class DnsCacheResolver {
    private _cache;
    constructor({ initialCache }?: {
        initialCache?: Map<string, string> | undefined;
    });
    resolve(host: string): Promise<string | undefined>;
    clearCache(): void;
    removeCache(host: string): void;
    get cache(): Map<string, string>;
}

declare type ModifiedUrlParameters = {
    host: string;
    port: string;
    protocol: string;
    hostname: string;
};
declare const toMaybeUrl: (originalUrl: RequestInfo, modifiedParams: ModifiedUrlParameters) => URL;
declare type CatcherOptions = {
    dnsCache?: DnsCacheResolver;
    headerFactory?: (headers?: HeadersInit) => Headers;
};
declare const fetchCatchDns: <T extends {
    headers?: HeadersInit | undefined;
}, R extends {
    json: () => Promise<any>;
}>(fetch: FetchFn<T, R>, { dnsCache, headerFactory, }?: CatcherOptions) => FetchFn<T, R>;

export { ApiRequestOptions, AuthConductorClient, CancelablePromise, ConductorClient, ConductorClientAPIConfig, ConductorHttpRequest, DnsCacheResolver, FetchFn, OpenAPIConfig, OrkesApiConfig, baseOrkesConductorClient, fetchCatchDns, orkesConductorClient, request, toMaybeUrl };
